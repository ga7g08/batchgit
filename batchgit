#!/bin/bash

# Define some useful variables for printing
bold=`tput bold`
normal=`tput sgr0`

#function that assigns n number of command line arguements
assignDynamicDir () {
        numCurArg=1
        while [ $numCurArg -lt $# ]; do
                numCurArg=$((numCurArg+1))
                Dir[$numCurArg]=${!numCurArg}
        done
}

#function that goes through your list of repos in ~/.batchgitrc and asks which to keep
wipeRepos () {
        echo -e "\n${bold}WIPE MODE"
        echo -e "==========${normal}\n"
        let i=1
        #cycles through dirs in file
        for dir in "${paths[@]}"; do
                let i+=1
                cd $dir
                REPO=${PWD##*/}
                echo ${bold}"Repository: $REPO ${normal}"
                echo "on path:$(pwd)"
                echo "Wipe? (Y/N): "
                read delornay </dev/tty
                case $delornay in 
                        [Yy][eE][sS]|[yY])
                                del=yes
                                ;;
                        [Nn][Oo]|[Nn])
                                del=no
                                ;;
                        [Qq][Uu][Ii][Tt]|[Qq]|[Ee][Xx][Ii][Tt]|[Qq]|[Ee])
                                del=leave
                                ;;
                        *)
                                del=nonsense
                                ;;
                esac
                #these should be incorporated in line as in checkbatchgit function
                #don't delete anything
                if [[ $del == "no" ]]; then
                        echo "Not wiped"
                        unset del
                fi
                if [[ $del == "yes" ]]; then
                        #if yes to delete then moves up one and recursively deletes
                        echo "$PWD"
                        cd ..
                        #could have sudo here to save y for write protected file
                        #but don't want to force sudo
                        rm -r $REPO
                        echo "Wiped"
                        unset del
                fi
                #quits
                if [[ $del == "leave" ]]; then
                        echo "Goodbye!"
                        unset del
                        exit
                fi
                #if it doesn't match one of the above then it takes the safe option
                #Could change this to return back to function
                if [[ $del == "nonsense" ]]; then
                        echo "That choice was unclear so untouched"
                        unset del
                fi
                printf "\n"
        done
        exit
}

#function that checks that the ~/.batchgitrc exists or if its empty and 
#runs find git
checkbatchgit () {
        #checks that batchgitrc exists, if not then goes
        #to function to search for current repos
        if [[ ! -f ~/.batchgitrc ]]; then
                findgitrepos func1
        fi
        #if file does exist, then check how many lines are in it
        numberInbatchgitrc=$(wc -l < ~/.batchgitrc)
        #if zero lines (i.e. empty) then searches for repos as above
        if [[ $numberInbatchgitrc == "0" ]]; then
                findgitrepos func1
        fi
        #if has lines, set paths array to them
        if [[ -f ~/.batchgitrc ]]; then
                paths=( $(cat ~/.batchgitrc) )     
        fi
}

#function that finds git repos on the disk
findgitrepos () {
        #Runs a find to look for repos
        findgit=( $(find ~ -type d -name .git | xargs -n 1 dirname) )
        #counts how many are inside
        numfind=${#findgit[@]}
        func1=$1
        #tells user how many repos they have
        echo -e "There are $numfind git repositories \n"
        #if file doesn't exist, then makes one
        if [[ ! -f ~/.batchgitrc ]]; then
                touch ~/.batchgitrc
                echo -e "making a ~/.batchgitrc file \n"
        #if it does exist then it makes a backup
        else
                mv ~/.batchgitrc ~/.batchgitrc.bak
                touch ~/.batchgitrc
                echo -e "making a new ~/.batchgitrc file and backing up old to ~/.batchgitrc.bak \n"
        fi
        #runs through all the repos it has found
        for gdir in "${findgit[@]}"; do
                        echo -e "$gdir"
                        echo "Include this repository? (Y/N): "
                        read incRepo </dev/tty
                        case $incRepo in 
                                #Can keep track of repo, and if so writes it to file
                                [Yy][eE][sS]|[yY])
                                        echo $gdir >> ~/.batchgitrc
                                        ;;
                                #no action if not kept
                                [Nn][Oo]|[Nn])
                                        :
                                        ;;
                                #option to quit
                                [Qq][Uu][Ii][Tt]|[Qq]|[Ee][Xx][Ii][Tt]|[Qq]|[Ee])
                                        exit
                                        ;;
                                #if there is nonsense, then just return to begin
                                *)
                                        findgitrepos
                                        ;;
                        esac
                echo -e "\n"
        done
}

#function that asks which repos to bootstrap
bootstrapchoice () {
        #For bootstrap mode, asks which should be written to boostrap file
        echo "Would you like to add this repository to the bootstrap (Y/N)?: "
        read addornay </dev/tty
        #again, I can makes these inline choices to save lines/time
        case $addornay in 
                [Yy][eE][sS]|[yY])
                        add=yes
                        ;;
                [Nn][Oo]|[Nn])
                        add=no
                        ;;
                [Qq][Uu][Ii][Tt]|[Qq]|[Ee][Xx][Ii][Tt]|[Qq]|[Ee])
                        add=leave
                        ;;
                *)
                        add=nonsense
                        ;;
        esac
        #do nothing if not
        if [[ $add == "no" ]]; then
                echo "Not added"
                unset add
        fi
        #if yes then write to file
        if [[ $add == "yes" ]]; then
                #echo the remote address to one file
                echo $remotesClean >> ~/batchgit-takeaway/bootstraprepo
                relativeFilepath=$(dirname $locdir)
                relativeFilepath2=$(echo $relativeFilepath | sed -e 's|^/[^/]*||' -e 's|^/[^/]*||' -e 's|^/||')
                #echo the filepath that the repo lives in (i.e. the full parent file path)
                #and change the user name to $USER for compatibility.
                echo "$relativeFilepath2" >> ~/batchgit-takeaway/bootstrapdir
                echo "Added"
                unset add
        fi
        if [[ $add == "leave" ]]; then
                #quit if thats your choice
                echo "Goodbye!"
                unset add
                exit
        fi
        if [[ $add == "nonsense" ]]; then
                #nonsensical return to the beginning.
                echo "That choice was unclear"
                unset add
                bootstrapchoice
        fi
}

#function that ensures the number of repos to bootstrap
#matches the number of directories that are present
checkrepodirmatch () {
        #before running the bootstrap
        #get the list of remotes
        clones=( $(cat ~/batchgit-takeaway/bootstraprepo) )
        #get the parent file paths
        localRepo=( $(cat ~/batchgit-takeaway/bootstrapdir) )
        #count the numbers of each
        lenclones=$(wc -l < ~/batchgit-takeaway/bootstraprepo)
        lenlocalRepo=$(wc -l < ~/batchgit-takeaway/bootstrapdir)
        #ensure backup ran correctly and there is an equal number of both
        if [[ $lenlocalRepo != $lenclones ]]; then
                echo "The number of directories does not match the number of remote locations"
                exit
        fi
}

#function that asks whether repo should be cloned or not
confirmClone () {
        #ask whether to clone or not
        echo "Would you like to clone this repository to this location? (Y/N): "
        read cloneornay </dev/tty
        case $cloneornay in 
                [Yy][eE][sS]|[yY])
                        clonethis=yes
                        ;;
                [Nn][Oo]|[Nn])
                        clonethis=no
                        ;;
                [Qq][Uu][Ii][Tt]|[Qq]|[Ee][Xx][Ii][Tt]|[Qq]|[Ee])
                        clonethis=leave
                        ;;
                *)
                        clonethis=nonsense
                        ;;
        esac
        #Wow, I really hated putting thise things up there where they belong
        #Beer coding is not efficient coding
        if [[ $clonethis == "no" ]]; then
                echo "Not cloned"
                unset clonethis
        fi
        #if answer is yes then git clone the ith number in the array
        if [[ $clonethis == "yes" ]]; then
                git clone ${clones[$i]}
                echo "Cloned"
                unset clonethis
        fi
        if [[ $clonethis == "leave" ]]; then
                echo "Goodbye!"
                unset clonethis
                exit
        fi
        #if you enter nonsense, you are just going to have to try again
        if [[ $clonethis == "nonsense" ]]; then
                echo "That choice was unclear"
                unset clonethis
                confirmClone
        fi
}

#function that checks the git status output for different types of
#modifications and then echoes them
gitStatus () {
        #gives the repo name
        REPO=${PWD##*/}
        #returns the branch
        BRANCH=$(git rev-parse --abbrev-ref HEAD)
        #prints the repository name and branch to stdout
        echo -e ${bold}"Repository: $REPO ${normal} $BRANCH"
        #looks for types of modifications that can popup in git status
        untracked=$(git status | sed -n -e '/Untracked/,$p' | tail -n +4 | sed '/^$/,$d' | sed 's/^[ \t]*//g')
        modified=$(git ls-files -m)
        deleted=$(git status | sed -n -e '/deleted:/,$p' | grep "deleted" | sed -e 's/.*deleted://g' -e 's/^[ \t]*//g')
        commit=$(git status | grep -w "commit" | sed -e 's/.*by //g' -e 's/\.//g' -e 's/#//g' | head -n 1)
        committed=$(git status | sed -n -e '/committed:/,$p' | grep "modified:" | sed -e 's/.*modified://g' -e 's/^[ \t]*//g')
        newfiles=$(git status | sed -n -e '/committed:/,$p' | grep "new file" | sed -e 's/.*new file://g' -e 's/^[ \t]*//g')
        #status of commit
        commitStatus=$(git status | sed -n -e '/commit/,$p' | grep -w "commit" | sed -e 's/.* is //g' -e 's/ of.*//g')
        commitAhead=$(git status | grep "ahead" | sed -e 's/.*by //g' -e 's/ commit.//g' -e 's/\.//g')
        commitBehind=$(git status | grep "behind" | sed -e 's/.*by //g' -e 's/ commit.//g')
        commitDiverge=$(git status | grep "diverged"*)
        #if there are commited files echoes that
        if [[ ! -z $committed ]]; then
                echo -e "Commited: \n\e[1;31m$committed\e[0m"
        fi
        #if there are new files, echoes that
        if [[ ! -z $newfiles ]]; then
                echo -e "New: \n\e[1;32m$newfiles\e[0m"
        fi
        #if there are deleted files, echoes that
        if [[ ! -z $deleted ]]; then
                echo -e "Deleted: \n\e[1;31m$deleted\e[0m"
        fi
        #if there are untracked files, echoes that
        if [[ ! -z $untracked ]]; then
                echo -e "Untracked: \n\e[1;31m$untracked\e[0m"
        fi
        #if there are modified files, echoes that
        if [[ ! -z $modified ]]; then
                echo -e "Modified: \n\e[1;31m$modified\e[0m"
        fi
        #checks status of commit, in front, ahead or diverged. Never seen diverged
        #happen though so I can't guarantee it works
        if [[ ! -z $commitAhead ]] || [[ ! -z $commitBehind ]]; then
                if [[ ! -z $commitAhead ]]; then
                        echo -e "Commit: \n\e[1;31m$commitAhead ahead\e[0m"
                fi
                if [[ ! -z $commitBehind ]]; then
                        echo -e "Commit: \n\e[1;31m$commitBehind, behind\e[0m"
                fi
        #look for divergence
        elif [[ ! -z $commitDiverge ]]; then
                echo "Divergence has occured"
        #not sure when this one might pop up
        elif [[ ! -z $commitAhead ]] && [[ ! -z $commitBehind ]]; then
                echo "You are ahead and behind"
        fi
        echo ""
}

#function that pulls repos
gitPull () {
        REPO=${PWD##*/}
        BRANCH=$(git rev-parse --abbrev-ref HEAD)
        echo ${bold}"Repository: $REPO ${normal} $BRANCH"
		git pull
        printf "\n"
}

#function that pushes repos
gitPush () {
        REPO=${PWD##*/}
        BRANCH=$(git rev-parse --abbrev-ref HEAD)
        echo ${bold}"Repository: $REPO ${normal} $BRANCH"
        #if pushonly then only pushes
        if [[ $1 == "-pushonly" ]] || [[ $1 == "-po" ]] || [[ $now == "gpush" ]] ; then
                git push
        #otherwise will do a pull before pushing. for safety
        else
                git pull
                git push
        fi
        printf "\n"
}

#function that checks for different types of commits
gitCommit () {
        numMod=$(git status | grep -c "modified")
        numNew=$(git status | grep -c "new file")
        numUntr=$(git status | grep -c "untracked")
        numDel=$(git status | grep -c "deleted")
        numTotal=$(($numNew + $numMod + $numUntr + $numDel))
        REPO=${PWD##*/}
        BRANCH=$(git rev-parse --abbrev-ref HEAD)
        echo ${bold}"Repository: $REPO ${normal} $BRANCH"
}

#Array where paths are held
paths=( $(cat ~/.batchgitrc) )     

#Check to ensure all local directories still exist
for dir in "${paths[@]}"; do
        #checks that the directory still exists before running anything
        if [[ ! -d $dir ]]; then
                echo -e "The $dir directory doesn't exist anymore and has been removed from the config file"
                sed -e "s|$dir||g" -i  ~/.batchgitrc
        fi
done

#arguement to backup
if [[ $1 == "--backup" ]]; then
        #if the flag for backup mode has been used
        #check if the takeaway directory doesn't already exists
        if [[ ! -d ~/batchgit-takeaway ]]; then
                echo "Building a takeaway box for you at ${bold}~/batchgit-takeaway${normal}"
                echo "This will be where the files for bootstrapping will live"
                mkdir ~/batchgit-takeaway
                echo "It might be an idea for you to put a copy of batchgit-takeaway in the folder too"
                echo ""
        fi
        #if the following files already exist, back them up and make new ones.
        if [[ -f ~/batchgit-takeaway/bootstraprepo ]]; then
                echo -e "Bootstraprepo file already exists, making a back up at ~/batchgit-takeaway/bootstraprepo.bak\n"
                mv ~/batchgit-takeaway/bootstraprepo ~/batchgit-takeaway/bootstraprepo.bak
        fi
        if [[ -f ~/batchgit-takeaway/bootstrapdir ]]; then
                echo -e "Bootstrapdir file already exists, making a back up at ~/batchgit-takeaway/bootstrapdir.bak\n"
                mv ~/batchgit-takeaway/bootstrapdir ~/batchgit-takeaway/bootstrapdir.bak
        fi
        #check if a batchgitrepo exists, if not then tell them to run it. Or let the function run
        if [[ ! -f ~/.batchgitrc ]]; then
                echo "You don't have a ~/.batchgitrc file."
                echo "This can be created by running batchgit -find"
                echo "or the following"
                findgitrepos
        fi
        #backup mode begins
        echo -e "\n${bold}BACKUP MODE"
        echo -e "===========${normal}\n"
        #cycle through files in the batchgitrc and ask if they should be added to the clone
        while read locdir; do
                echo -e "Local repository is $locdir"
                cd /$locdir
                remotes=$(git remote -v | grep "fetch")
                remotesClean=$(echo $remotes | sed -e 's/origin//' | sed -e 's/ (fetch)//')
                remotePresent=1
                remoteTotal=$(echo $remotes | grep -c "fetch")
                #Count how many remotes exist, actually I am not sure of this works
                if [[ $remoteTotal -gt "1" ]]; then
                        echo "The are $remoteTotal remotes"
                        while [[ $remotePresent -le $remoteTotal ]]; do
                                let remotePresent+=1
                                echo $remotes
                                echo $($remotes | grep -m$remotePresent)
                                echo "Sorry, I haven't got round to making multiple remotes work."
                                echo "Please let me know what the output from having multiple remotes looks like and I'll try and make it work"
                        done
                else
                        #echo the remote
                        echo "There is only one remote branch"
                        echo -e "Which is:${bold}$remotesClean${normal}"
                fi
                #run through the multiple choice for bootstrapping
                bootstrapchoice
                echo -e "\n"
        done < ~/.batchgitrc
        #changes all of the first line to user, this assumes that all directories live in ~
        #something to optimise if anyone beside me actually uses it.
        sed -e 's|^|/home/$USER/|g' -i ~/batchgit-takeaway/bootstrapdir
        #function to check backup list has cycle through properly
        checkrepodirmatch
        exit
fi

#if clone flag is used
if [[ $1 == "--clone" ]]; then
        #enter if clone flag used
        echo -e "\n${bold}CLONE MODE"
        echo -e "==========${normal}\n"
        #checks that repos match paths in number
        checkrepodirmatch
        let i=0
        for dir in ${localRepo[@]}; do
                #if directory not present then it makes it
                if [[ ! -d ${localRepo[$i]} ]]; then
                        if [ "${localRepo[$i]}" != '/home/$USER/' ]; then
                                echo "Making the directory ${localRepo[$i]}"
                                eval mkdir -p "${localRepo[$i]}"
                        fi
                fi
                #moves to the dir in question
                eval cd ${localRepo[$i]}
                #tells you where you are
                echo "this dir is ${bold}$(pwd)${normal}"
                #tells you what it should match
                echo "which should match ${localRepo[$i]}"
                #tells you what its going to put there
                echo "for cloning ${bold}${clones[$i]}${normal}"
                confirmClone
                let i+=1
                echo -e "\n"
        done 
        exit
fi

#add new repo to config file
if [[ $1 == "-add" ]] || [[ $1 == "-a" ]]; then
        #add individual dir/repo mode
        if [[ ! -z $2 ]]; then 
                #checks rc exists, think this is / should be a function
                if [[ ! -f ~/.batchgitrc ]]; then
                        touch ~/.batchgitrc
                        echo -e "making ~/.batchgitrc file \n"
                fi
                #think that is isnt actually necessary, anyways, adds current dir if ./ used
                if [[ $2 == "./" ]]; then
                        echo $(pwd) >> ~/.batchgitrc
                        echo "adding $(pwd) to ~/.batchgitrc"
                #allows adding subdir of current by checking slashes are not used
                elif [[ $2 != "*/*" ]]; then
                        PWD=$(pwd)
                        #adds based on pwd plus arguement
                        pwdrepdir=$PWD"/"$2
                        echo "adding $pwdrepdir to ~/.batchgitrc"
                        echo $pwdrepdir >> ~/.batchgitrc
                #allows adding full file path
                else
                        echo $2 >> ~/.batchgitrc
                        echo -e "Added $2 to the ~/.batchgitrc file"
                fi
                #removes any duplicates
                sort -u -o ~/.batchgitrc ~/.batchgitrc
        else
                #error if dir not added
                echo "you need to add the directory after the flag!"
        fi
        #needs to be replaced by function
        choice=y
fi

#recursive addition of repos
if [[ $1 == "-addrecursive" ]] || [[ $1 == "-ar" ]]; then
        if [[ -z $2 ]]; then 
                findrecurgit=( $(find ./ -type d -name .git | xargs -n 1 dirname) )
                here=y
        else
                findrecurgit=( $(find $2 -type d -name .git | xargs -n 1 dirname) )
                here=n
        fi
        for dir in "${findrecurgit[@]}"; do
                if [[ $here == "y" ]] || [[ $2 == "./" ]]; then
                        repdir=$(echo $dir | cut -c 2-)
                        PWD=$(pwd)
                        pwdrepdir=$PWD$repdir
                else
                        pwdrepdir=$dir
                fi
                        echo -e "$pwdrepdir"
                        read -p "Would you like to watch this repository? (y/n): " -n 1 -r
                        if [[ $REPLY =~ ^[Yy]$ ]]; then
                                echo -e "\n$pwdrepdir" >> ~/.batchgitrc
                        fi
                        echo -e "\n"
        done
        sort -u -o ~/.batchgitrc ~/.batchgitrc
        choice=y
fi

#removes single repo manually
if [[ $1 == "-rm" ]] || [[ $1 == "-r" ]] || [[ $1 == "-remove" ]]; then
        if [[ ! -z $2 ]]; then 
                if [[ $2 == "./" ]]; then
                        sed -e "s|$(pwd)||g" -i  ~/.batchgitrc
                elif [[ $2 != "*/*" ]]; then
                        PWD=$(pwd)
                        pwdrepdir=$PWD"/"$2
                        echo "removing $pwdrepdir"
                        sed -e "s|$pwdrepdir||g" -i  ~/.batchgitrc
                else
                        sed -e "s|$2||g" -i  ~/.batchgitrc
                fi
                sort -u -o ~/.batchgitrc ~/.batchgitrc
        else
                echo "you need to add the directory after the flag!"
        fi
        choice=y
fi

#tests for config file, or runs if forced to redo config
if [[ $1 == "-f" ]] || [[ ! -f ~/.batchgitrc ]] || [[ $1 == "-find" ]]; then
        func1=$1
        findgitrepos func1
fi

#multiple choice for no option or post config
if [[ $# == 0 ]] || [[ $choice == "y" ]]; then
#gives some options
#want to overhaul this section
while true; do
        echo -e """
1) \t git status
2) \t git pull
3) \t git pull and push
4) \t git push only
5) \t delete repos
6) \t quit
        """
        read -p "What happens now? " whatnow
        case $whatnow in
                #could turn these into functions, but work fine as is
                [1]* ) now=gstatus;break;;
                [2]* ) now=gpull;break;;
                [3]* ) now=gpullpush;break;;
                [4]* ) now=gpush;break;;
                [5]* ) now=wipe;break;;
                [6]* ) now=quit;break;;
                [quit]* ) now=quit;break;;
                [exit]* ) now=quit;break;;
        esac
done
fi

#quits script if option selected
if [[ $now == "quit" ]]; then
        printf "\n"
        exit
fi

#deletes blank lines from the batchgitrc file
#could potentially be moved into the loop above
sed -e '/^$/d' -i ~/.batchgitrc 

#git status
if [[ $1 == "-status" ]] || [[ $now == "gstatus" ]] || [[ $1 == "-s" ]]; then
        if [[ $# -gt 1 ]]; then
                assignDynamicDir $@
                for dynamicDir in ${Dir[@]}; do
                        echo "Checking specific named repositories: ${bold}$dynamicDir${normal}"
                        inRc=$(grep "$dynamicDir" ~/.batchgitrc)
                        if [[ ! -z $inRc ]]; then
                                cd $inRc
                                gitStatus
                        fi
                        if [[ -z $inRc ]]; then
                                echo "No repository named $dynamicDir exists in your ~/.batchgitrc file"
                                echo ""
                        fi
                done
        fi
        if [[ $# == "1" ]]; then
                #goes through the folders in the list
                for dir in "${paths[@]}"; do
                        #moves into the directory listed
                        cd $dir
                        gitStatus 
                done
        fi
        exit
fi

#git pull
if [[ $1 == "-pull" ]] || [[ $now == "gpull" ]] || [[ $1 == "-d" ]]; then
        if [[ $# -gt 1 ]]; then
                assignDynamicDir $@
                for dynamicDir in ${Dir[@]}; do
                        echo "Checking specific named repositories: ${bold}$dynamicDir${normal}"
                        inRc=$(grep "$dynamicDir" ~/.batchgitrc)
                        if [[ ! -z $inRc ]]; then
                                cd $inRc
                                gitPull
                        fi
                        if [[ -z $inRc ]]; then
                                echo "No repo named $dynamicDir exists in your ~/.batchgitrc file"
                                echo ""
                        fi
                done
        fi
        if [[ $# == "1" ]]; then
                #goes through the folders in the list
                for dir in "${paths[@]}"; do
                        #moves into the directory listed
                        cd $dir
                        gitPull 
                done
        fi
exit
fi

#git push
if [[ $1 == "-push" ]] || [[ $now == "gpush" ]] || [[ $now == "gpullpush" ]] || [[ $1 == "-u" ]] || [[ $1 == "-n" ]] || [[ $1 == "-po" ]] || [[ $1 == "-pushonly" ]]; then
        if [[ $# -gt 1 ]]; then
                assignDynamicDir $@
                for dynamicDir in ${Dir[@]}; do
                        echo "Checking specific named repositories: ${bold}$dynamicDir${normal}"
                        inRc=$(grep "$dynamicDir" ~/.batchgitrc)
                        if [[ ! -z $inRc ]]; then
                                cd $inRc
                                gitPush
                        fi
                        if [[ -z $inRc ]]; then
                                echo "No repo named $dynamicDir exists in your ~/.batchgitrc file"
                                echo ""
                        fi
                done
        fi
        if [[ $# == "1" ]]; then
                #goes through the folders in the list
                for dir in "${paths[@]}"; do
                        #moves into the directory listed
                        cd $dir
                        gitPush
                done
        fi
        #not sure what this is doing here
        if [[ $1 == "-n" ]]; then
                echo -e "\nAll done for the day!\n"
                        printf """
+      o     +              o   
    +             o     +       +
o          +
    o  +           +        +
+        o     o       +        o
-_-_-_-_-_-_-_,------,      o 
_-_-_-_-_-_-_-|   /\_/\  
-_-_-_-_-_-_-~|__( ^ .^)  +     +  
_-_-_-_-_-_-_-''  ''      
+      o         o   +       o
    +         +
o        o         o      o     +
    o           +
+      +     o        o      +    
\n"""
        fi
exit
fi

#commit flag, complicated due to flag and commit message catching
if [[ $1 == "-commit" ]] || [[ $1 == "-c" ]] || [[ $1 == "-cp" ]]; then
        #if there is only one arguement, it has to be -c so batchcommit with 
        #whatthecommit commit message
        if [[ $# == "1" ]]; then
                #goes through the folders in the list
                for dir in "${paths[@]}"; do
                        #moves into the directory listed
                        cd $dir
                        gitCommit
                        if [[ $numTotal != "0" ]]; then
                                #adds files
                                git add .
                                git add -A
                                #commits
                                commitMessage=$(curl -s http://whatthecommit.com/ | grep -A 1 'id="content"' | sed 's/.*<p>//' | tail -n 1)
                                git commit -m "$commitMessage"
                                printf "\n"
                                #if -cp flag present then it will also push after committing
                                if [[ $1 == "-cp" ]]; then
                                        git push
                                fi
                                echo ""
                        fi
                done
        fi
        #if there are two arguements, then there are combinations of options
        if [[ $# == "2" ]]; then
                #if there are spaces in the second argument, then probably a commit message then batchgit
                if [[ "$2" =~ ( |\') ]]; then #'
                        for dir in "${paths[@]}"; do
                                #moves into the directory listed
                                cd $dir
                                gitCommit
                                if [[ $numTotal != "0" ]]; then
                                        #adds files
                                        git add .
                                        git add -A
                                        #commits
                                        echo "commit message is $2"
                                        commitmessage=$2
                                        git commit -m "$2"
                                        printf "\n"
                                        #if -cp flag present then it will also push after committing
                                        if [[ $1 == "-cp" ]]; then
                                                git push
                                        fi
                                        echo ""
                                fi
                        done
                #if it doesn't look like a message its probably for a specific dir
                #however as there are only two arguments have to use a whathecommit message
                else
                        echo "Checking specific named repositories: ${bold}$2${normal}"
                        inRc=$(grep "$2" ~/.batchgitrc)
                        cd $inRc
                        gitCommit
                        if [[ $numTotal != "0" ]]; then
                                #adds files
                                git add .
                                git add -A
                                #commits
                                commitMessage=$(curl -s http://whatthecommit.com/ | grep -A 1 'id="content"' | sed 's/.*<p>//' | tail -n 1)
                                git commit -m "$commitMessage"
                                printf "\n"
                                #if -cp flag present then it will also push after committing
                                if [[ $1 == "-cp" ]]; then
                                        git push
                                fi
                                echo ""
                        fi
                fi
        fi
        #if there are more than two options then there are more options
        if [[ $# -gt "2" ]]; then
                #assigns dir variables to arguements
                numCurArg=1
                while [ $numCurArg -lt $# ]; do
                        numCurArg=$((numCurArg+1))
                        Dir[$numCurArg]=${!numCurArg}
                done
                #if the last arguement looks like a commit message, make it the commit message
                if [[ ${Dir[$#]} =~ ( |\') ]]; then #'
                        commitmessage=${Dir[$#]}
                        lastVal=$(($#-1))
                #otherwise set it to whathecommit
                else
                        commitMessage=$(curl -s http://whatthecommit.com/ | grep -A 1 'id="content"' | sed 's/.*<p>//' | tail -n 1)
                        lastVal=$#
                fi
                for (( c=2; c<=$lastVal; c++ )); do
                        inRc=$(grep "${Dir[$c]}" ~/.batchgitrc)
                        if [[ ! -z $inRc ]]; then
                                cd $inRc
                                gitCommit
                                if [[ $numTotal != "0" ]]; then
                                        #adds files
                                        git add .
                                        git add -A
                                        #commits
                                        git commit -m "$commitmessage"
                                        printf "\n"
                                        #if -cp flag present then it will also push after committing
                                        if [[ $1 == "-cp" ]]; then
                                                git push
                                        fi
                                        echo ""
                                fi
                        fi
                        if [[ -z $inRc ]]; then
                                echo "No repository named $dynamicDir exists in your ~/.batchgitrc file"
                                echo ""
                        fi
                done
        fi
        exit
fi

#catch wipe flag
if [[ $1 == "--wipe" ]] || [[ $now == "wipe" ]]; then
        #sets func1 to $1 and passes this to checkbatchgit, then will come back to cycle through wipeRepos
        #dont think i need to set this to $1: change
        func1=$1
        checkbatchgit func1 
        wipeRepos
fi

#error message
echo "sorry, that command didn't work! Try again"
printf "\n"
exit
